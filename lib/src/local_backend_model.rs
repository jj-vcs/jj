// Autogenerated by Thrift Compiler (0.17.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;

//
// File
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct File {
  pub id: Vec<u8>,
  pub executable: bool,
}

impl File {
  pub fn new(id: Vec<u8>, executable: bool) -> File {
    File {
      id,
      executable,
    }
  }
}

impl TSerializable for File {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<File> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("File.id", &f_1)?;
    verify_required_field_exists("File.executable", &f_2)?;
    let ret = File {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      executable: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
    o_prot.write_bytes(&self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("executable", TType::Bool, 2))?;
    o_prot.write_bool(self.executable)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TreeValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TreeValue {
  File(File),
  SymlinkId(Vec<u8>),
  TreeId(Vec<u8>),
  ConflictId(Vec<u8>),
}

impl TSerializable for TreeValue {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TreeValue> {
    let mut ret: Option<TreeValue> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = File::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TreeValue::File(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(TreeValue::SymlinkId(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(TreeValue::TreeId(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(TreeValue::ConflictId(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TreeValue"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TreeValue"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TreeValue");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TreeValue::File(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("file", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TreeValue::SymlinkId(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("symlink_id", TType::String, 2))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
      TreeValue::TreeId(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("tree_id", TType::String, 3))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
      TreeValue::ConflictId(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("conflict_id", TType::String, 4))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TreeEntry
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TreeEntry {
  pub name: String,
  pub value: TreeValue,
}

impl TreeEntry {
  pub fn new(name: String, value: TreeValue) -> TreeEntry {
    TreeEntry {
      name,
      value,
    }
  }
}

impl TSerializable for TreeEntry {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TreeEntry> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<TreeValue> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TreeValue::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TreeEntry.name", &f_1)?;
    verify_required_field_exists("TreeEntry.value", &f_2)?;
    let ret = TreeEntry {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TreeEntry");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Struct, 2))?;
    self.value.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Tree
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Tree {
  pub entries: Vec<TreeEntry>,
}

impl Tree {
  pub fn new(entries: Vec<TreeEntry>) -> Tree {
    Tree {
      entries,
    }
  }
}

impl TSerializable for Tree {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Tree> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TreeEntry>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TreeEntry> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = TreeEntry::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Tree.entries", &f_1)?;
    let ret = Tree {
      entries: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tree");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entries", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.entries.len() as i32))?;
    for e in &self.entries {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Timestamp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Timestamp {
  pub millis_since_epoch: i64,
  pub tz_offset: i32,
}

impl Timestamp {
  pub fn new(millis_since_epoch: i64, tz_offset: i32) -> Timestamp {
    Timestamp {
      millis_since_epoch,
      tz_offset,
    }
  }
}

impl TSerializable for Timestamp {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Timestamp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Timestamp.millis_since_epoch", &f_1)?;
    verify_required_field_exists("Timestamp.tz_offset", &f_2)?;
    let ret = Timestamp {
      millis_since_epoch: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tz_offset: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Timestamp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("millis_since_epoch", TType::I64, 1))?;
    o_prot.write_i64(self.millis_since_epoch)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tz_offset", TType::I32, 2))?;
    o_prot.write_i32(self.tz_offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Signature
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Signature {
  pub name: String,
  pub email: String,
  pub timestamp: Timestamp,
}

impl Signature {
  pub fn new(name: String, email: String, timestamp: Timestamp) -> Signature {
    Signature {
      name,
      email,
      timestamp,
    }
  }
}

impl TSerializable for Signature {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Signature> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Timestamp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Timestamp::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Signature.name", &f_1)?;
    verify_required_field_exists("Signature.email", &f_2)?;
    verify_required_field_exists("Signature.timestamp", &f_3)?;
    let ret = Signature {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      email: f_2.expect("auto-generated code should have checked for presence of required fields"),
      timestamp: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Signature");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 2))?;
    o_prot.write_string(&self.email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::Struct, 3))?;
    self.timestamp.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Commit
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Commit {
  pub parents: Vec<Vec<u8>>,
  pub predecessors: Vec<Vec<u8>>,
  pub root_tree: Vec<u8>,
  pub change_id: Vec<u8>,
  pub description: String,
  pub author: Signature,
  pub committer: Signature,
}

impl Commit {
  pub fn new(parents: Vec<Vec<u8>>, predecessors: Vec<Vec<u8>>, root_tree: Vec<u8>, change_id: Vec<u8>, description: String, author: Signature, committer: Signature) -> Commit {
    Commit {
      parents,
      predecessors,
      root_tree,
      change_id,
      description,
      author,
      committer,
    }
  }
}

impl TSerializable for Commit {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Commit> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Vec<u8>>> = None;
    let mut f_2: Option<Vec<Vec<u8>>> = None;
    let mut f_3: Option<Vec<u8>> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<Signature> = None;
    let mut f_7: Option<Signature> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_bytes()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_bytes()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = Signature::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = Signature::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Commit.parents", &f_1)?;
    verify_required_field_exists("Commit.predecessors", &f_2)?;
    verify_required_field_exists("Commit.root_tree", &f_3)?;
    verify_required_field_exists("Commit.change_id", &f_4)?;
    verify_required_field_exists("Commit.description", &f_5)?;
    verify_required_field_exists("Commit.author", &f_6)?;
    verify_required_field_exists("Commit.committer", &f_7)?;
    let ret = Commit {
      parents: f_1.expect("auto-generated code should have checked for presence of required fields"),
      predecessors: f_2.expect("auto-generated code should have checked for presence of required fields"),
      root_tree: f_3.expect("auto-generated code should have checked for presence of required fields"),
      change_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      description: f_5.expect("auto-generated code should have checked for presence of required fields"),
      author: f_6.expect("auto-generated code should have checked for presence of required fields"),
      committer: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Commit");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parents", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.parents.len() as i32))?;
    for e in &self.parents {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("predecessors", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.predecessors.len() as i32))?;
    for e in &self.predecessors {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("root_tree", TType::String, 3))?;
    o_prot.write_bytes(&self.root_tree)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("change_id", TType::String, 4))?;
    o_prot.write_bytes(&self.change_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 5))?;
    o_prot.write_string(&self.description)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("author", TType::Struct, 6))?;
    self.author.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("committer", TType::Struct, 7))?;
    self.committer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ConflictPart
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ConflictPart {
  pub content: TreeValue,
}

impl ConflictPart {
  pub fn new(content: TreeValue) -> ConflictPart {
    ConflictPart {
      content,
    }
  }
}

impl TSerializable for ConflictPart {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ConflictPart> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TreeValue> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TreeValue::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ConflictPart.content", &f_1)?;
    let ret = ConflictPart {
      content: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ConflictPart");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::Struct, 1))?;
    self.content.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Conflict
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Conflict {
  pub removes: Vec<ConflictPart>,
  pub adds: Vec<ConflictPart>,
}

impl Conflict {
  pub fn new(removes: Vec<ConflictPart>, adds: Vec<ConflictPart>) -> Conflict {
    Conflict {
      removes,
      adds,
    }
  }
}

impl TSerializable for Conflict {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Conflict> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ConflictPart>> = None;
    let mut f_2: Option<Vec<ConflictPart>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ConflictPart> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = ConflictPart::read_from_in_protocol(i_prot)?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ConflictPart> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = ConflictPart::read_from_in_protocol(i_prot)?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Conflict.removes", &f_1)?;
    verify_required_field_exists("Conflict.adds", &f_2)?;
    let ret = Conflict {
      removes: f_1.expect("auto-generated code should have checked for presence of required fields"),
      adds: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Conflict");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("removes", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.removes.len() as i32))?;
    for e in &self.removes {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("adds", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.adds.len() as i32))?;
    for e in &self.adds {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

