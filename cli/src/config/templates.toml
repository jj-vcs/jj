[templates]
bookmark_list = '''
if(remote,
  if(tracked,
    "  " ++ separate(" ",
      label("bookmark", "@" ++ remote),
      if(present, format_tracked_remote_ref_distances(self)),
    ) ++ if(present, format_ref_targets(self), " (not created yet)"),
    label("bookmark", name ++ "@" ++ remote) ++ format_ref_targets(self),
  ),
  label("bookmark", name) ++ if(present, format_ref_targets(self), " (deleted)"),
) ++ "\n"
'''

revision_summary = 'format_revision_summary_with_refs(self, bookmarks)'

file_annotate = '''
separate(" ",
  commit.change_id().shortest(8),
  pad_end(8, truncate_end(8, commit.author().email().local())),
  revision_timestamp(commit).local().format('%Y-%m-%d %H:%M:%S'),
  pad_start(4, line_number),
) ++ ": " ++ content
'''

config_list = 'builtin_config_list'

draft_revision_description = 'builtin_draft_revision_description'

duplicate_description = 'description'

revision_trailers = ''

evolog = 'builtin_evolog_compact'

file_list = '''
format_path(path) ++ "\n"
'''
file_show = ''

git_push_bookmark = '"push-" ++ change_id.short()'

log = 'builtin_log_compact'
show = 'builtin_log_detailed'
op_log = 'builtin_op_log_compact'
op_show = 'builtin_op_log_compact'

revert_description = '''
concat(
  'Revert "' ++ description.first_line() ++ '"' ++ "\n",
  "\n",
  "This reverts commit " ++ commit_id ++ ".\n",
)
'''

tag_list = '''
label("tag", name) ++ format_ref_targets(self) ++ "\n"
'''

workspace_list = '''
name ++ ": " ++ format_revision_summary_with_refs(target, target.bookmarks()) ++ "\n"
'''

op_summary = '''
separate(" ",
  self.id().short(),
  if(root,
    label("root", "root()"),
    surround("(", ")", format_timestamp(self.time().end())),
  ),
  self.description().first_line(),
)
'''

log_node = '''
if(
  config("ui.graph.style").as_string().starts_with("ascii"),
  builtin_log_node_ascii,
  builtin_log_node
)
'''

op_log_node = '''
if(
  config("ui.graph.style").as_string().starts_with("ascii"),
  builtin_op_log_node_ascii,
  builtin_op_log_node
)
'''

[template-aliases]
'hyperlink(url, text)' = '''
concat(
  raw_escape_sequence("\e]8;;" ++ url ++ "\e\\"),
  text,
  raw_escape_sequence("\e]8;;\e\\"),
)
'''

'format_config_item(x)' = '''
if(x.overridden(),
  indent("# ", x.name() ++ " = " ++ x.value()),
  x.name() ++ " = " ++ x.value(),
)
'''

builtin_config_list = '''
label(if(overridden, "overridden"),
  format_config_item(self) ++ "\n")
'''

builtin_config_list_detailed = '''
label(if(overridden, "overridden"),
  format_config_item(self) ++ " # " ++ separate(" ", source, path) ++ "\n")
'''

builtin_draft_revision_description = '''
concat(
  coalesce(description, default_revision_description, "\n"),
  "\n",
  "JJ: Change ID: " ++ format_short_change_id(change_id) ++ "\n",
  surround(
    "JJ: This commit contains the following changes:\n", "",
    indent("JJ:     ", diff.summary()),
  ),
)
'''

builtin_evolog_compact = '''
concat(
  builtin_log_compact(commit),
  if(operation,
    separate(" ",
      label("separator", "--"),
      "operation",
      operation.id().short(),
      operation.description().first_line(),
    ) ++ "\n",
  ),
)
'''

builtin_log_oneline = 'builtin_log_oneline(self)'
'builtin_log_oneline(revision)' = '''
if(revision.root(),
  format_root_revision(revision),
  label(
    separate(" ",
      if(revision.current_working_copy(), "working_copy"),
      if(revision.immutable(), "immutable", "mutable"),
      if(revision.conflict(), "conflicted"),
    ),
    concat(
      separate(" ",
        format_short_change_id_with_hidden_and_divergent_info(revision),
        format_short_signature_oneline(revision.author()),
        format_timestamp(revision_timestamp(revision)),
        revision.bookmarks(),
        revision.tags(),
        revision.working_copies(),
        if(revision.git_head(), label("git_head", "git_head()")),
        format_short_revision_id(revision.commit_id()),
        if(revision.conflict(), label("conflict", "conflict")),
        if(config("ui.show-cryptographic-signatures").as_boolean(),
          format_short_cryptographic_signature(revision.signature())),
        if(revision.empty(), empty_commit_marker),
        if(revision.description(),
          revision.description().first_line(),
          label(if(revision.empty(), "empty"), description_placeholder),
        ),
      ) ++ "\n",
    ),
  )
)
'''

builtin_log_compact = 'builtin_log_compact(self)'
'builtin_log_compact(revision)' = '''
if(revision.root(),
  format_root_revision(revision),
  label(
    separate(" ",
      if(revision.current_working_copy(), "working_copy"),
      if(revision.immutable(), "immutable", "mutable"),
      if(revision.conflict(), "conflicted"),
    ),
    concat(
      format_short_revision_header(revision) ++ "\n",
      separate(" ",
        if(revision.empty(), empty_commit_marker),
        if(revision.description(),
          revision.description().first_line(),
          label(if(revision.empty(), "empty"), description_placeholder),
        ),
      ) ++ "\n",
    ),
  )
)
'''

builtin_log_redacted = 'builtin_log_redacted(self)'
'builtin_log_redacted(revision)' = '''
if(revision.root(),
  format_root_revision(revision),
  label(
    separate(" ",
      if(revision.current_working_copy(), "working_copy"),
      if(revision.immutable(), "immutable", "mutable"),
      if(revision.conflict(), "conflicted"),
    ),
    concat(
      format_short_revision_header_redacted(revision) ++ "\n",
      separate(" ",
        if(revision.empty(), empty_commit_marker),
        label("description", "(redacted)"),
      ) ++ "\n",
    ),
  )
)
'''

builtin_log_compact_full_description = 'builtin_log_compact_full_description(self)'
'builtin_log_compact_full_description(revision)' = '''
if(revision.root(),
  format_root_revision(revision),
  label(
    separate(" ",
      if(revision.current_working_copy(), "working_copy"),
      if(revision.immutable(), "immutable", "mutable"),
      if(revision.conflict(), "conflicted"),
    ),
    concat(
      format_short_revision_header(revision) ++ "\n",
      separate(" ",
        if(revision.empty(), empty_commit_marker),
        if(revision.description(),
          revision.description().trim_end() ++ "\n",
          label(if(revision.empty(), "empty"), description_placeholder),
        ),
      ) ++ "\n",
    ),
  )
)
'''

builtin_log_comfortable = 'builtin_log_compact ++ "\n"'
builtin_log_detailed = 'builtin_log_detailed(self)'
'builtin_log_detailed(revision)' = '''
concat(
  "Commit ID: " ++ revision.commit_id() ++ "\n",
  "Change ID: " ++ revision.change_id() ++ "\n",
  surround("Bookmarks: ", "\n", separate(" ", revision.local_bookmarks(), revision.remote_bookmarks())),
  surround("Tags     : ", "\n", revision.tags()),
  "Author   : " ++ format_detailed_signature(revision.author()) ++ "\n",
  "Committer: " ++ format_detailed_signature(revision.committer())  ++ "\n",
  if(config("ui.show-cryptographic-signatures").as_boolean(),
    "Signature: " ++ format_detailed_cryptographic_signature(revision.signature()) ++ "\n"),
  "\n",
  indent("    ",
    if(revision.description(),
      revision.description().trim_end(),
      label(if(revision.empty(), "empty"), description_placeholder)) ++ "\n"),
  "\n",
)
'''

builtin_op_log_compact = 'builtin_op_log_compact(self)'
'builtin_op_log_compact(op)' = '''
label(if(op.current_operation(), "current_operation"),
  coalesce(
    if(op.snapshot(), format_snapshot_operation(op)),
    if(op.root(), format_root_operation(op)),
    format_operation(op),
  )
)
'''

builtin_op_log_comfortable = 'builtin_op_log_compact ++ "\n"'
builtin_op_log_oneline = 'builtin_op_log_oneline(self)'
'builtin_op_log_oneline(op)' = '''
label(if(current_operation, "current_operation"),
  coalesce(
    if(op.snapshot(), format_snapshot_operation_oneline(op)),
    if(op.root(), format_root_operation(op)),
    format_operation_oneline(op),
  )
)
'''
builtin_op_log_redacted = 'builtin_op_log_redacted(self)'
'builtin_op_log_redacted(op)' = '''
label(if(op.current_operation(), "current_operation"),
  coalesce(
    if(op.snapshot(), format_snapshot_operation_redacted(op)),
    if(op.root(), format_root_operation(op)),
    format_operation_redacted(op),
  )
)
'''

default_revision_description = '""'
empty_commit_marker = 'label("empty", "(empty)")'
description_placeholder = 'label("description placeholder", "(no description set)")'
email_placeholder = 'label("email placeholder", "(no email set)")'
name_placeholder = 'label("name placeholder", "(no name set)")'
revision_summary_separator = 'label("separator", " | ")'

# Hook points for users to customize the default templates:
'revision_timestamp(revision)' = 'revision.committer().timestamp()'
'format_short_id(id)' = 'id.shortest(8)'
'format_short_change_id(id)' = 'format_short_id(id)'
'format_short_revision_id(id)' = 'format_short_id(id)'
'format_short_operation_id(id)' = 'id.short()'
'format_path(path)' = 'path.display()'
'format_short_signature(signature)' = '''
  coalesce(signature.email(), email_placeholder)'''
'format_short_signature_oneline(signature)' = '''
  coalesce(signature.email().local(), email_placeholder)'''

'format_detailed_signature(signature)' = '''
  coalesce(signature.name(), name_placeholder)
  ++ " <" ++ coalesce(signature.email(), email_placeholder) ++ ">"
  ++ " (" ++ format_timestamp(signature.timestamp()) ++ ")"'''
# For operations, when it makes a difference whether to use the start time or
# the end time, the latter is more meaningful. For mutating operations, this is
# the moment when the repo was actually modified due to this operation. TODO:
# This macro might need a better name, e.g. `format_operation_time_range`.
'format_time_range(time_range)' = '''
  time_range.end().ago() ++ label("time", ", lasted ") ++ time_range.duration()'''
'format_timestamp(timestamp)' = 'timestamp.local().format("%Y-%m-%d %H:%M:%S")'

'format_revision_summary_with_refs(revision, refs)' = '''
label(if(revision.current_working_copy(), "working_copy"),
  separate(" ",
    format_short_change_id_with_hidden_and_divergent_info(revision),
    format_short_revision_id(revision.commit_id()),
    separate(revision_summary_separator,
      refs,
      separate(" ",
        if(revision.conflict(), label("conflict", "(conflict)")),
        if(revision.empty(), empty_commit_marker),
        if(revision.description(),
          revision.description().first_line(),
          label(if(revision.empty(), "empty"), description_placeholder),
        ),
      ),
    ),
  ),
)
'''

'format_root_revision(root)' = '''
label("immutable",
  separate(" ",
    format_short_change_id(root.change_id()),
    label("root", "root()"),
    format_short_revision_id(root.commit_id()),
    root.bookmarks(),
  ) ++ "\n"
)
'''

'format_ref_targets(ref)' = '''
if(ref.conflict(),
  separate("\n",
    " " ++ label("conflict", "(conflicted)") ++ ":",
    ref.removed_targets().map(|c| "  - " ++ format_revision_summary_with_refs(c, "")).join("\n"),
    ref.added_targets().map(|c| "  + " ++ format_revision_summary_with_refs(c, "")).join("\n"),
  ),
  ": " ++ format_revision_summary_with_refs(ref.normal_target(), ""),
)
'''

'format_tracked_remote_ref_distances(ref)' = '''
if(ref.tracking_present(), surround("(", ")", separate(", ",
  if(!ref.tracking_ahead_count().zero(),
    if(ref.tracking_ahead_count().exact(),
      "ahead by " ++ ref.tracking_ahead_count().exact() ++ " commits",
      "ahead by at least " ++ ref.tracking_ahead_count().lower() ++ " commits")),
  if(!ref.tracking_behind_count().zero(),
    if(ref.tracking_behind_count().exact(),
      "behind by " ++ ref.tracking_behind_count().exact() ++ " commits",
      "behind by at least " ++ ref.tracking_behind_count().lower() ++ " commits")),
)))
'''

'format_operation(op)' = '''
concat(
  separate(" ", format_short_operation_id(op.id()), op.user(), format_time_range(op.time())), "\n",
  op.description().first_line(), "\n",
  if(op.tags(), op.tags() ++ "\n"),
)
'''
'format_operation_redacted(op)' = '''
concat(
  separate(" ", format_short_operation_id(op.id()), format_user_redacted(op.user()), format_time_range(op.time())), "\n",
  op.description().first_line(), "\n",
  "(redacted)",
)
'''
'format_snapshot_operation(op)' = 'format_operation(op)'
'format_snapshot_operation_redacted(op)' = 'format_operation_redacted(op)'
'format_root_operation(root)' = 'separate(" ", root.id().short(), label("root", "root()")) ++ "\n"'


'format_operation_oneline(op)' = '''
separate(" ",
  format_short_operation_id(op.id()), op.user(), format_time_range(op.time()),
  op.description().first_line(),
  if(op.tags(), op.tags()),
) ++ "\n"
'''
'format_snapshot_operation_oneline(op)' = 'format_operation_oneline(op)'

# We have "hidden" override "divergent", since a hidden revision does not cause
# change id conflicts and is not affected by such conflicts; you have to use the
# revision id to refer to a hidden revision regardless.
'format_short_change_id_with_hidden_and_divergent_info(revision)' = '''
if(revision.hidden(),
  label("hidden",
    format_short_change_id(revision.change_id()) ++ " hidden"
  ),
  label(if(revision.divergent(), "divergent"),
    format_short_change_id(revision.change_id()) ++ if(revision.divergent(), "??")
  )
)
'''

'format_short_revision_header(revision)' = '''
separate(" ",
  format_short_change_id_with_hidden_and_divergent_info(revision),
  format_short_signature(revision.author()),
  format_timestamp(revision_timestamp(revision)),
  revision.bookmarks(),
  revision.tags(),
  revision.working_copies(),
  if(revision.git_head(), label("git_head", "git_head()")),
  format_short_revision_id(revision.commit_id()),
  if(revision.conflict(), label("conflict", "conflict")),
  if(config("ui.show-cryptographic-signatures").as_boolean(),
    format_short_cryptographic_signature(revision.signature())),
)
'''

'format_short_revision_header_redacted(revision)' = '''
separate(" ",
  format_short_change_id_with_hidden_and_divergent_info(revision),
  label("author", format_user_redacted(revision.author())),
  format_timestamp(revision_timestamp(revision)),
  revision.bookmarks().map(|bookmark| concat(
    "bookmark-", hash(bookmark.name()).substr(0, 4),
    if(bookmark.remote(),
      "@remote-" ++ hash(bookmark.remote()).substr(0, 4),
      if(!bookmark.synced(), "*")
    )
  )),
  revision.tags().map(|tag| concat("tag-", hash(tag.name()).substr(0, 4))),
  revision.working_copies(),
  if(revision.git_head(), label("git_head", "git_head()")),
  format_short_revision_id(revision.commit_id()),
  if(revision.conflict(), label("conflict", "conflict")),
  if(config("ui.show-cryptographic-signatures").as_boolean(),
    format_short_cryptographic_signature(revision.signature())),
)
''' # TODO: Possibly add some kind of repo-unique salt to the hash methods, if it makes users feel more secure (right now, `main` will always be `branch-c8c7a` for every repo)

'format_detailed_cryptographic_signature(signature)' = '''
if(signature,
  separate(" ",
    label("signature status " ++ signature.status(), signature.status()),
    "signature by",
    coalesce(signature.display(), "(unknown)"),
    signature.key(),
  ),
  "(no signature)",
)
'''
'format_short_cryptographic_signature(signature)' = '''
if(signature,
  label("signature status", concat(
    "[",
    label(signature.status(), coalesce(
      if(signature.status() == "good", "✓︎"),
      if(signature.status() == "unknown", "?"),
      "x",
    )),
    "]",
  ))
)
'''

'format_user_redacted(user)' = '''label("user", concat('user-', hash(user).substr(0, 4)))'''

builtin_log_node = '''
coalesce(
  if(!self, label("elided", "~")),
  label(
    separate(" ",
      if(current_working_copy, "working_copy"),
      if(immutable, "immutable", "mutable"),
      if(conflict, "conflicted"),
    ),
    coalesce(
      if(current_working_copy, "@"),
      if(immutable, "◆"),
      if(conflict, "×"),
      "○",
    )
  )
)
'''

builtin_log_node_ascii = '''
coalesce(
  if(!self, label("elided", "~")),
  label(
    separate(" ",
      if(current_working_copy, "working_copy"),
      if(immutable, "immutable", "mutable"),
      if(conflict, "conflicted"),
    ),
    coalesce(
      if(current_working_copy, "@"),
      if(immutable, "+"),
      if(conflict, "x"),
      "o",
    )
  )
)
'''

builtin_op_log_node = '''
coalesce(
  if(current_operation, label("current_operation", "@")),
  "○",
)
'''

builtin_op_log_node_ascii = '''
coalesce(
  if(current_operation, label("current_operation", "@")),
  "o",
)
'''

# The first line is a fixed magic date string used by
# programs like file(1) to identify that this is output from
# 'git format-patch'.
# See https://git-scm.com/docs/git-format-patch#_description
git_format_patch_email_headers = '''
  concat(
    "From " ++ commit_id ++ " Mon Sep 17 00:00:00 2001\n",
    "From: " ++ author ++ "\n",
    "Date: " ++ author.timestamp().format("%a, %-e %b %Y %T %z") ++ "\n",
    "Subject: [PATCH] " ++ description.first_line() ++ "\n",
    "\n",
    description.remove_prefix(description.first_line()).trim_start(),
    "---\n",
    indent(" ", diff.stat()),
    "\n"
  )
'''

"format_signed_off_by_trailer(revision)" = '"Signed-off-by: " ++ revision.committer() ++ "\n"'

# Gerrit change id is 40 chars, jj change id is 32, so we need some padding.
# `6a6a6964` is the hexadecimal of `jjid` in ASCII, just to not pad with zeros.
"format_gerrit_change_id_trailer(revision)" = '"Change-Id: I" ++ revision.change_id().normal_hex() ++ "6a6a6964\n"'
